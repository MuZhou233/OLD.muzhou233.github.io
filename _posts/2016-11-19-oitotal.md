---
layout: post
title: NOIP2016考前知识总结
date: 2016-10-25
categories: oi
tags: [oi]
description: NOIP2016考前知识总结
---

**要复赛了! 要退役了! 快总结一下好了...**  
(排名不分先后, 慢慢添加内容)  

- 使用 ! 标记的为重要内容  
- 使用 * 标记的为(应该)用不到的内容  
- 如有错误, 请联系我  
- 右侧目录会显示不完整, 请善用网页缩放  

***

#数据结构

- 链表 !堆 表达式树 !线段树 Trie树 HASH表

##!栈

```c++  
int Stack[N], top = 0;
void push (int x) {
	Stack[top++] = x;
}
int front () {
	return Stack[--top];
}
void pop () {
	top--;
}
bool empty () {
	return top == 0;
}
```  

或  

```c++  
#include<stack>
```  

##!队列

```c++  
int Queue[N], head = 0, tail = 0;
void push (int x) {
	Queue[head++] = x;
	if (head == N) head = 0;
}
int front () {
	return Queue[tail];
}
void pop () {
	tail++;
	if (tail == N) tail = 0;
}
bool empty () {
	return head > tail ? head-tail : head+N-tail;
}
```  

或  

```c++  
#include<queue>
```  

##二叉搜索树

可选: Splay, Treap, 红黑树, 以及->

```c++  
#include<set>
#include<map>
```  

STL内部是写的鲁棒性极高的红黑树  

##!树状数组

树状数组好写好用, 常见的无法解决的问题是区间最值  

很重要的事:  
**关于 lowbit() 的正确性, 理性的证明不重要, 你可以尝试模拟计算过程来感性地认知**  
**树状数组不能维护从 0 开始的区间, 有些时候你需要加 1 来使区间左端点不是 0**  

***

使用树状数组的三个阶段:  

###改点求段

给出若干`点修改`与`区间查询`, 使用树状数组维护  

```c++  
int bit1[N];
int lowbit (int x) {return x&-x;}
void add1 (p, x) {
	while (p > N) {
		bit1[p] += x;
		p += lowbit(x);
	}
}
int sum1 (int r) {
	int ret = 0;
	while (r) {
		ret += bit1[r];
		r -= lowbit(r);
	}
}
int query1 (int l, int r) {return sum1(r) - sum1(l-1);}
```  

###改段求点

给出若干`区间修改`和`点查询`, 使用树状数组维护  

```c++  
int bit2[N];
void add2 (int r, int x) {
	while (r) {
		bit2[r] += x;
		r -= lowbit(r);
	}
}
void add2 (int l, int r, int x) {
	add(r, x);
	add(l-1, -x);
}
int sum2 (int p) {
	int ret = 0;
	while (p < N) {
		ret += bit2[p];
		p += lowbit(p);
	}
}
int query2 (int p) {return sum2(p);}
```  

###改段求段

给出若干`区间修改`和`区间查询`, 使用树状数组维护  

这个操作需要一前两个为基础  
考虑 l 固定的修改与查询(即前缀):  

- 我们使用 bit1 存储的数据会在 r 更大的查询中被用到, 表示它前面的区间修改的总和(即前缀和)  
- 我们使用 bit2 存储的数据会在 r 更小的查新中被用到, 表示它前面区间中每个点的修改  

推广即可  

```c++
void add3 (int l, int r, int x) {
	add1(r, x*(r-l));
	add1(l-1, -x*(l-1));
	add2(r, x);
	add2(l-1, -x);
}
int query3 (int l, int r) {return sum1(r) - sum1(l-1) + sum2(r) * r - sum2(l-1) * (l-1);}
```  

***

三种图的存储方式  

##邻接矩阵

NONE  

##!邻接表

```c++  
struct E{
	int to, v;
};
vector <E> G[N];
```  

##邻接链表/前向星

```c++  
struct E{
	int to, v, nex;
};
vector <E> G;
int head[N];
```  

***

##!并查集 

```c++  
int fa[N];
int father (int x) {return x == fa[x] ? x : fa[x]=father(fa[x]);}
void Union(int x, int y){fa[father(x)] = father(y);}
```  
并查集可以用来判断图的连通性, 还可以用来做一些奇怪的事情, 比如`[NOIP2010]关押罪犯`可以用并查集`造点`  

#图论

- 欧拉回路 强连通分量

##拓扑序

```c++  
bool vis[N];
int tp[N], top = 0;
void tuopu (int p) {
	if (vis[p]) return;
	for (int i = head[p]; ~i; i = G[i].nex) tuopu (G[i].to);
	tp[top++] = p;
}
```  

我在[网络流](http://muzhou.tk/oi/2016/10/24/wangluoliu2/)中也用到了这个算法

##!最短路

有多种算法: Bellman-Ford, Dijkstra, Floyd-Warshall(全源最短路)  
常用SPFA(super fast), 是对Bellman-Ford的队列优化版本  

```c++  
queue <int> que;
bool inque[N];
int v[N];
void spfa (int s) {
	for (int i = 0; i < N; i++) v[i] = INF;
	memset (inque, 0, sizeof(inque));
	while (!que.empty()) que.pop();
	que.push(s);
	inque[s] = 1;
	v[s] = 0;
	while (!que.empty()) {
		int now = que.front(); que.pop();
		inque[now] = 0;
		for (int i = head[now]; i != -1; i = G[i].nex) if( v[now] + G[i].v < v[G[i].to]){
			v[G[i].to] = v[now] + G[i].v;
			if (inque[G[i].to]) continue;
			que.push(G[i].to);
			inque[G[i].to] = 1;
		}
	}
}
```  

##差分约束

差分约束系统: 不等式组中每个不等式只含有一个变量  

差分约束可以经过转化, 使用最短路算法求解  

对于每个不等式, 可以构造出一条边  

- 不等号包含等号(大于等于, 小于等于)时, 边权为 0  
- 不等号不包含等号(大于, 小于)时, 边权为 1  

即可得到一张图  

##*网络流

写了两篇博客: [浅谈预流推进网络流算法](http://muzhou.tk/blog/2016/10/17/wangluoliu/) [再谈预流推进-更快算法](http://muzhou.tk/oi/2016/10/24/wangluoliu2/)  

#!贪心

#!暴力

- 模拟 枚举 搜索 剪枝 *开关问题 分块 离散化

#分治

- 归并排序 *树上分治(重心分解)

##!快速排序

```c++  
sort(a, a + n);
```  

##!二分查找/答案

外层内容相差无几, 注意**区间开闭**问题, 挂了无数次, 请教 [Coolkid](http://cogs.pro/cogs/user/detail.php?uid=5328) 去  

```c++  
int l = L, r = R, mid;
while (l < r) {
	mid = (l + r) / 2;
	if (judge(mid)) {
		/*---*/
	} else {
		/*---*/
	}
}
```  

#字符串

- HASH

##*Manacher

这个算法可以很快的计算出回文子串的长度  

```c++  
void Manacher (char *s, int *length) {
	memset (length, 0, sizeof(length));
	for (int i = 0; i < strlen(s); i++) {
		for (int &j = length[i]; i-j >= 0 && i+j < strlen(s) && s[i-j-1] == s[i+j+1]; j++);
		for (int j = length[i]; j > 0; j--) length[i+j] = max(length[i+j], length[i-j]);
	}
}
```  

计算得出的 length[] 数组含义如下:  
当 length[i] == j 时, s[i] 前面 j 个字符与后面 j 个字符形成回文串  

##*KMP

字符串匹配算法, 效率很高, 不一定考  

```c++  
void init_kmp (int *last, char *s) {
memset (last, -1, sizeof(last));
for (int i = 1; i < strlen(s); i++) {
	int &now = last[i]; now = last[i-1];
	while ((~last[now]) && s[last[now]+1] != s[i]) now = last[now];
	if (last[now] || s[last[now]+1] == s[i]) now++;
}

int kmp (char *t, char *s, int *last) {
	int ret = 0;
	for (int i = 0, j = 0; j < strlen(t); i++, j++) {
		if (i == strlen(s) ret++, i = last[i-1]+1;
		while (i>0 && s[i]!=t[i]) i = last[i-1]+1;
		if(i == 0 && s[i] != t[j]) i--;
	}
	return ret;
}
```  

##*AC自动机

只说一句话: KMP + Trie = AC自动机  

#数论

- !高精度 欧拉函数 !唯一分解定理 !二项式定理 加法原理 乘法原理 基本计数问题 *期望与概率 *矩阵乘法 *矩阵快速幂

##!斐波那契数列

大部分数学题中会用到, 如果有一道数学题, 你想打表, 最好看一看打出来的表和斐波那契数列有没有关系, 别问我为什么, 问 [Coolkid](http://cogs.pro/cogs/user/detail.php?uid=5328) 去  

##!素数测试

其实有更快的算法, 但是貌似用不到  

```c++  
bool is_prime (int x) {
	if (x < 2) return 0;
	for (int i = sqrt(x); i > 1; i--) if (x % i == 0) return 0;
	return 1;
}
```  

##!素数筛法

这里提到的算法叫做`埃氏筛法`, 效率比较特别: `O(nloglogn)`, 打素数表专用  

```c++  
bool prime[N];
void sieve () {
	fill(prime, prime+N, 1);
	prime[0] = prime[1] = 0;
	for (int i = 2; i < N; i++) if (prime[i])
		for (int j = 2; i * j < N; j++) prime[i*j] = 0;
}
```  

##!扩展欧几里得

实在重要, 不言而喻  

```c++  
int gcd(int a, int b) {return b == 0 ? a : gcd(b, a%b);}
int exgcd (int a, int b, int &x, int &y) {
```  

##!快速幂

同样是数学基础算法  

```c++  
int mod (int a, int b, int c) {
	int ret = 1;
	while (b) {
		if (b & 1) ret = ret * a % c;
		a = a * a % c;
		b >>= 1;
	}
	retrun ret;
}
```  

#倍增

- !LCA倍增 ST表

#!DP

- 阶段类 区间类  预处理 前缀和优化

***

关于单调队列/栈, 我另有一篇博客[在此](http://muzhou.tk/blog/2016/10/15/dandiaoduilie/)  
下面代码以升序为例  

##单调栈

```c++  
int a[N], top = 0;
void push (int x) {
	while (a[top-1] > x) top--;
	a[top++] = x;
}
```  

##单调队列

```c++  
struct A{
	int num, time;
};
A a[N], head = 0, tail = 0;
void push (int x, int t, int l) {
	while (head > tail && a[tail].time < t-l) tail++;
	while (head > tail && a[head-1].num > x) head--;
	a[head++] = (A){x, t};
}
```  

