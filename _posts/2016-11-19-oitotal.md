---
layout: post
title: 备战NOIP-知识总结
date: 2016-10-25
categories: oi
tags: [oi]
description: NOIP2016考前知识总结
---

**要复赛了! 要退役了! 快总结一下好了...**  
(排名不分先后, 慢慢添加内容)  

- 使用 ! 标记的为重要内容  
- 使用 * 标记的为(应该)用不到的内容  
- 如有错误, 请联系我, 感谢  

***

# 数据结构

- 链表 表达式树 !线段树 Trie树 HASH表

## !栈

```c++  
int Stack[N], top = 0;
void push (int x) {
	Stack[top++] = x;
}
int front () {
	return Stack[--top];
}
void pop () {
	top--;
}
bool empty () {
	return top == 0;
}
```  

或  

```c++  
#include<stack>
std::stack<int>s;
void s::push(int);
int s::top();
void s::pop();
bool s::empty();
```  

## !队列

```c++  
int Queue[N], head = 0, tail = 0;
void push (int x) {
	Queue[head++] = x;
	if (head == N) head = 0;
}
int front () {
	return Queue[tail];
}
void pop () {
	tail++;
	if (tail == N) tail = 0;
}
bool empty () {
	return head > tail ? head-tail : head+N-tail;
}
```  

或  

```c++  
#include<queue>
std::queue<int>que;
void que::push(int);
int que::front();
void que::pop();
bool que::empty();
```  

## !堆

堆分大根堆和小根堆, 可以高效的维护集合中的最值, 支持动态修改, 下面是实现的最好的例子

```c++  
#include<queue>
std::priority_queue<int>que;
void que::push(int);
int que::top();
void que::pop();
bool que::empty();
```  

## 二叉搜索树

可选: Splay, Treap, 红黑树, 以及  

```c++  
#include<set>
#include<map>
```  

STL内部是写的鲁棒性极高的红黑树  

## !树状数组

树状数组好写好用, 常见的无法解决的问题是区间最值  

很重要的事:  
**关于 lowbit() 的正确性, 理性的证明不重要, 你可以尝试模拟计算过程来感性地认知**  
**树状数组不能维护从 0 开始的区间, 有些时候你需要加 1 来使区间左端点不是 0**  

***

使用树状数组的三个阶段:  

### 改点求段

给出若干`点修改`与`区间查询`, 使用树状数组维护  

```c++  
int bit1[N];
int lowbit (int x) {return x&-x;}
void add1 (p, x) {
	while (p > N) {
		bit1[p] += x;
		p += lowbit(x);
	}
}
int sum1 (int r) {
	int ret = 0;
	while (r) {
		ret += bit1[r];
		r -= lowbit(r);
	}
}
int query1 (int l, int r) {return sum1(r) - sum1(l-1);}
```  

### 改段求点

给出若干`区间修改`和`点查询`, 使用树状数组维护  

```c++  
int bit2[N];
void add2 (int r, int x) {
	while (r) {
		bit2[r] += x;
		r -= lowbit(r);
	}
}
void add2 (int l, int r, int x) {
	add(r, x);
	add(l-1, -x);
}
int sum2 (int p) {
	int ret = 0;
	while (p < N) {
		ret += bit2[p];
		p += lowbit(p);
	}
}
int query2 (int p) {return sum2(p);}
```  

### 改段求段

给出若干`区间修改`和`区间查询`, 使用树状数组维护  

这个操作需要一前两个为基础  
考虑 l 固定的修改与查询(即前缀):  

- 我们使用 bit1 存储的数据会在 r 更大的查询中被用到, 表示它前面的区间修改的总和(即前缀和)  
- 我们使用 bit2 存储的数据会在 r 更小的查新中被用到, 表示它前面区间中每个点的修改  

推广即可  

```c++
void add3 (int l, int r, int x) {
	add1(r, x*(r-l));
	add1(l-1, -x*(l-1));
	add2(r, x);
	add2(l-1, -x);
}
int query3 (int l, int r) {return sum1(r) - sum1(l-1) + sum2(r) * r - sum2(l-1) * (l-1);}
```  

***

三种图的存储方式  

## 邻接矩阵

NONE  

## !邻接表

```c++  
struct E{
	int to, v;
};
vector <E> G[N];
```  

## 邻接链表/前向星

```c++  
struct E{
	int to, v, nex;
};
vector <E> G;
int head[N];
```  

***

## !并查集 

```c++  
int fa[N];
int father (int x) {return x == fa[x] ? x : fa[x]=father(fa[x]);}
void Union(int x, int y){fa[father(x)] = father(y);}
```  
并查集可以用来判断图的连通性, 还可以用来做一些奇怪的事情, 比如`[NOIP2010]关押罪犯`可以用并查集`造点`  

# 图论

- 欧拉回路 强连通分量

## 拓扑序

```c++  
bool vis[N];
int tp[N], top = 0;
void tuopu (int p) {
	if (vis[p]) return;
	for (int i = head[p]; ~i; i = G[i].nex) tuopu (G[i].to);
	tp[top++] = p;
}
```  

我在[网络流](/oi/2016/10/24/wangluoliu2/)中也用到了这个算法

## !最短路

有多种算法: Bellman-Ford, Dijkstra, Floyd-Warshall(全源最短路)  
常用SPFA(super fast), 是对Bellman-Ford的队列优化版本  

```c++  
queue <int> que;
bool inque[N];
int v[N];
void spfa (int s) {
	for (int i = 0; i < N; i++) v[i] = INF;
	memset (inque, 0, sizeof(inque));
	while (!que.empty()) que.pop();
	que.push(s);
	inque[s] = 1;
	v[s] = 0;
	while (!que.empty()) {
		int now = que.front(); que.pop();
		inque[now] = 0;
		for (int i = head[now]; i != -1; i = G[i].nex) if( v[now] + G[i].v < v[G[i].to]){
			v[G[i].to] = v[now] + G[i].v;
			if (inque[G[i].to]) continue;
			que.push(G[i].to);
			inque[G[i].to] = 1;
		}
	}
}
```  

## 差分约束

差分约束系统: 不等式组中每个不等式只含有一个变量  

差分约束可以经过转化, 使用最短路算法求解  

对于每个不等式, 可以构造出一条边  

- 不等号包含等号(大于等于, 小于等于)时, 边权为 0  
- 不等号不包含等号(大于, 小于)时, 边权为 1  

即可得到一张图  

## *网络流

写了两篇博客: [浅谈预流推进网络流算法](/blog/2016/10/17/wangluoliu/) [再谈预流推进-更快算法](/oi/2016/10/24/wangluoliu2/)  

# !贪心

贪心算法的正确性常用`临位交换法`证明, 简单说就是将贪心方案中的任意两个元素交换位置之后与之前的方案进行对比, 其结果能代表整个贪心方案的正确性(前提是你的证明过程是正确的)  

# !暴力

- 模拟 枚举 搜索 剪枝 *开关问题 分块

## 离散化

当数据量小数字却很大时(例如[[NOIP2013]火柴排队](http://cogs.pro/cogs/problem/problem.php?pid=1438)), 我们可以使用离散化  
离散化就是保留数据之间的相对关系(大小关系)而忽略数据本身的数值大小, 没有什么具体代码  

# 分治

- 归并排序 *树上分治(重心分解)

## !快速排序

```c++  
#include<algorithm>
std::sort(a, a + n);
```  

## !二分查找/答案

外层内容相差无几, 注意**区间开闭**问题, 挂了无数次, 请教 [Coolkid](http://cogs.pro/cogs/user/detail.php?uid=5328) 去  

```c++  
int l = L, r = R, mid;
while (l < r) {
	mid = (l + r) / 2;
	if (judge(mid)) {
		/*---*/
	} else {
		/*---*/
	}
}
```  

# 字符串

- HASH

## *Manacher

这个算法可以很快的计算出回文子串的长度  

```c++  
void Manacher (char *s, int *length) {
	memset (length, 0, sizeof(length));
	for (int i = 0; i < strlen(s); i++) {
		for (int &j = length[i]; i-j >= 0 && i+j < strlen(s) && s[i-j-1] == s[i+j+1]; j++);
		for (int j = length[i]; j > 0; j--) length[i+j] = max(length[i+j], length[i-j]);
	}
}
```  

计算得出的 length[] 数组含义如下:  
当 length[i] == j 时, s[i] 前面 j 个字符与后面 j 个字符形成回文串  

## *KMP

字符串匹配算法, 效率很高, 不一定考  

```c++  
void init_kmp (int *last, char *s) {
memset (last, -1, sizeof(last));
for (int i = 1; i < strlen(s); i++) {
	int &now = last[i]; now = last[i-1];
	while ((~last[now]) && s[last[now]+1] != s[i]) now = last[now];
	if (last[now] || s[last[now]+1] == s[i]) now++;
}

int kmp (char *t, char *s, int *last) {
	int ret = 0;
	for (int i = 0, j = 0; j < strlen(t); i++, j++) {
		if (i == strlen(s) ret++, i = last[i-1]+1;
		while (i>0 && s[i]!=t[i]) i = last[i-1]+1;
		if(i == 0 && s[i] != t[j]) i--;
	}
	return ret;
}
```  

## *AC自动机

只说一句话: KMP + Trie = AC自动机  

# 数论

- 欧拉函数 !二项式定理 加法原理 乘法原理 基本计数问题 ＊期望与概率 ＊矩阵乘法 ＊矩阵快速幂

## !斐波那契数列

大部分数学题中会用到, 如果有一道数学题, 你想打表, 最好看一看打出来的表和斐波那契数列有没有关系, 别问我为什么, 问 [Coolkid](http://cogs.pro/cogs/user/detail.php?uid=5328) 去  

## !素数测试

其实有更快的算法, 但是貌似用不到  

```c++  
bool is_prime (int x) {
	if (x < 2) return 0;
	if (x == 2) return 1;
	for (int i = sqrt(x); i > 1; i--) if (x % i == 0) return 0;
	return 1;
}
```  

## !素数筛法

这里提到的算法叫做`埃氏筛法`, 效率比较特别: `O(nloglogn)`, 打素数表专用  

```c++  
bool prime[N];
void sieve () {
	fill(prime, prime+N, 1);
	prime[0] = prime[1] = 0;
	for (int i = 2; i < N; i++) if (prime[i])
		for (int j = 2; i * j < N; j++) prime[i*j] = 0;
}
```  

## !扩展欧几里得

实在重要, 不言而喻  

```c++  
int gcd(int a, int b) {return b == 0 ? a : gcd(b, a%b);}
int exgcd (int a, int b, int &d, int &x, int &y) {//d 是辅助变量
	if (!b) {d = a; x = 1; y = 0;}
	else {exgcd(b, a%b, d, y, x); y -= x * (a / b);}
}
```  

## !唯一分解定理

每个合数都可以唯一的分解为多个质数的积

```c++  
void wyfj (int *prime, int *num, int x) {
	memset (num, 0, sizeof(num));
	for (int i = 0; x; i++)
		while (x % prime[i] == 0) {
			num[i]++;
			x/=prime[i];
		}
}
```  

上面的函数(貌似)可以求出分解后的质数, 要求传入质数表  

## !快速幂

同样是数学基础算法  

```c++  
int mod (int a, int b, int c) {
	int ret = 1;
	while (b) {
		if (b & 1) ret = ret * a % c;
		a = a * a % c;
		b >>= 1;
	}
	retrun ret;
}
```  

## !高精度

模拟人的算数过程, 下面的模板仅供参考, 不是完全正确的代码  

```c++  
struct Bign{
	static const int N = 1000,M = 1;
	static const int powm = 10;// powm = pow(10,M);
	int a[N];
	// bool_type;
	bool operator < (const Bign &num) const {
		if(a[0] != num.a[0])return a[0] < num.a[0];
		const int *b = num.a;
		int th = a[0];
		while(a[th] == b[th] && th > 0) th--;
		return a[th] < b[th];
	}
	bool operator > (const Bign &num) const {return num < *this;}
	bool operator <= (const Bign &num) const {return !(num < *this);}
	bool operator >= (const Bign &num) const {return !(num > *this);}
	bool operator != (const Bign &num) const {return num < *this  || num > *this;}
	bool operator == (const Bign &num) const {return !(num != *this);}
	// =_type;
	Bign operator = (int num){
		memset(a,0,sizeof(a));
		while(num){
			a[++a[0]] = num % powm;
			num /= powm;
		}
		return *this;
	}
	Bign (int num = 0){*this = num;}
	// +_type;
	Bign operator + (const Bign &num) const {
		Bign ret = 1;
		const int *b = num.a;
		int *c = ret.a, buf = 0;
		for(int &i = c[0]; i <= max(a[0], b[0]) || buf; i++){
			c[i] = a[i] + b[i] + buf;
			buf = c[i] / powm;
			c[i] %= powm;
		}c[0]--;
		return ret;
	}Bign operator += (const Bign &num) const {return *this + num;}
	
	Bign operator + (const int num) const {
		Bign ret = num;
		return *this + ret;
	}Bign operator += (const int num) const {return *this + num;}
	// -_type;
	Bign operator - (const Bign &num) const {
		if(a < num.a) return num - *this;
		Bign ret = 1;
		const int *b = num.a;
		int *c = ret.a, buf = 0; 
		for(int &i = c[0]; i < a[0] || a[i] + buf; i++){
			c[i] = a[i] + powm - b[i] +	buf;
			buf = c[i] / powm - 1;
			c[i] %= powm;
		}
		while((!c[c[0]])&&c[0]>0)c[0]--;
		return ret;
	}Bign operator -= (const Bign &num) const {return *this - num;}
	
	Bign operator - (const int num) const {
		Bign ret = num;
		return *this - ret;
	}Bign operator -= (const int num) const {return *this - num;}
	// *_type;
	Bign operator * (const Bign &num) const {
		Bign ret;
		const int *b = num.a;
		int *c = ret.a;
		for(int i = 1; i <= b[0]; i++){
			int buf = 0;
			for(int j = 1; j <= a[0] || buf; j++){
				c[i+j-1] += a[j] * b[i] + buf;
				buf = c[i+j-1] / powm;
				c[i+j-1] %= powm;
			}
		}c[0] = a[0] + b[0];
		if(!c[c[0]]) c[0]--;
		return ret;
	}Bign operator *= (const Bign &num) const {return *this * num;}
	
	Bign operator * (const int num) const {
		Bign ret = num;
		return *this * ret;
	}Bign operator *= (const int num) const {return *this * num;}
	// /_type;
	Bign operator / (const int num) const {
		Bign ret = 1;
		int *c = ret.a, buf = 0;
		for(int i = a[0]; i > 0; i--){
			buf = buf * powm + a[i];
			c[i] = buf / num;
			buf %= num;
		}c[0] = a[0];
		for(int &i = c[0]; !c[i]; i--);
		buf = 0;
		for(int i = 1; i <= c[0] || buf; i++){
			c[i] += buf;
			buf = c[i] / powm;
		}
		return ret;
	}Bign operator /= (const int num) const {return *this - num;}
	// sqrt;
	friend Bign sqrt (const Bign&);
	// io;
	void in () {
		*this = 0;
		a[0] = 1;
		char buf;
		bool brea=0;
		for(int &i = a[0]; !brea; i++){
			for(int j = 1; j <= M; j++){
				buf = getchar();
				if(buf < '0' || buf > '9')
					{brea = 1; break;}
				a[i] += (buf - '0') * pow(10, j - 1);
			}
		}a[0]-=2;
		int l=1,r=a[0];
		while(l<r){
			int buf=a[l];
			a[l]=a[r];
			a[r]=buf;
			l++; r--;
		}
	}
	void out () {
		int *a = this -> a;
		for(int i = a[0]; i > 0; i--)
			printf("%d", a[i]);
		if(a[0]==0)putchar('0');
	}
};

Bign sqrt (const Bign &num){
	Bign l = 1, r = num;
	Bign mid, buf;
	while(l < r){
		mid = (r + l) / 2;
		buf = mid * mid;
		if(buf == num) break;
		if(buf >= num) r = mid;
		else l = mid + 1;
	}l=l-1;
	return l;
//	return l * l > num? l-1: l;
}
```  

# 倍增

- !LCA倍增 ST表

# !DP

- 阶段类 区间类  预处理 前缀和优化

***

关于单调队列/栈, 我另有一篇博客[在此](http://muzhou.tk/blog/2016/10/15/dandiaoduilie/)  
下面代码以升序为例  

## 单调栈

```c++  
int a[N], top = 0;
void push (int x) {
	while (a[top-1] > x) top--;
	a[top++] = x;
}
```  

## 单调队列

```c++  
struct A{
	int num, time;
};
A a[N], head = 0, tail = 0;
void push (int x, int t, int l) {
	while (head > tail && a[tail].time < t-l) tail++;
	while (head > tail && a[head-1].num > x) head--;
	a[head++] = (A){x, t};
}
```  

